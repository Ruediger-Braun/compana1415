.. -*- coding: utf-8 -*-

=========================================
Computergestützte Mathematik zur Analysis
=========================================

-------------------------------------------------------------------
Übersicht über die verwendeten Befehle, nach Lektionen geordnet
-------------------------------------------------------------------

.. contents:: Inhaltsverzeichnis
              :backlinks: none

Lektion 1
*********

Arithmetik
==========

+     Befehle werden mit ``;``
      oder ``:`` abgeschlossen.  Im
      ersten Fall wird das Ergebnis angezeigt, im zweiten nicht.  
      Zeilenende impliziert ``;``

+     ``+, -, *, /, ^``

      arithmetische Operatoren

+     ``!``

      Faktorielle

+     ``evalf(`` *x* ``)``

      numerische Auswertung von *x* auf 10 gültige Stellen

+     ``evalf(`` *x* ``,`` *n* ``)``

      numerische Auswertung von *x* auf *n* gültige Stellen      

+     ``Digits`` := *n*

      setzt die Genauigkeit auf *n* Stellen

Variablen
=========

+     ``:=``

      Zuweisung

+     ``=``

      Vergleichsoperator (später)

+     *a* ``:= '`` *a* ``'``

      Aufhebung einer Zuweisung

elementare Funktionen
=====================

+     ``sqrt``

      Quadratwurzel

+     ``sin, cos, tan, cot``

      trigonometrische Funktionen

+     ``arcsin, arccos, arctan, arccot``

      inverse trigonometrische Funktionen

..      ``arctan`` siehe auch in `Der Arcustangens`_

+     ``log, ln``

      natürlicher Logarithmus

+     ``exp``

      Exponentialfunktion

+     ``Pi``

      Ludolfsche Zahl pi
  
Vereinfachungen
===============

+     ``simplify``

      allgemeiner Vereinfachungsbefehl, siehe auch in Ersetzungen_

+     ``normal``

      Kürzen von Brüchen

+     ``normal(`` *f* ``, expanded)``
 
      dasselbe, aber Zähler und Nenner werden expandiert

+     ``expand``

      expandiert Polynome, trigonometrische Funktionen usw.

+     ``factor``

      faktorisiert Polynome

Hilfsprogramme
==============

+     ``restart``

      löscht alle Variablen

+     ``lprint``

      Ausgabe in 1D 

zurück zum Inhaltsverzeichnis_



Lektion 2
*********

dito Operator
=============

+     %

      Ergebnis der letzten Berechnung

+     Zugriff auf label ist nur mit der Maus möglich


Summen und Grenzwerte
=====================

+     ``sum(`` *f*, *n* ``=`` *a* ``..`` *b* ``)``

      Summe von *f* für *n* von *a* bis *b*, dabei ist *f* ein Ausdruck in *n*

+     ``infinity``

      Konstante unendlich

+     ``limit(`` *f* ``,`` *x* ``=`` *a* ``)``

      Grenzwert des Ausdrucks *f* in *x* = *a*

+     ``limit(`` *f* ``,`` *x* ``=`` *a* ``, right)``

      Grenzwert des Ausdrucks *f* in *x* = *a* von rechts (von links
      mit ``left``)

Ableitungen und Integrale
=========================

+     ``diff(`` *f* ``,`` *x* ``)``

      Ableitung des Ausdrucks *f* nach *x*

+     ``int(`` *f*, *x* ``)``

      Stammfunktion des Ausdrucks *f* bezüglich der Variablen *x*

+     ``int(`` *f*, *x* ``=`` *a* ``..`` *b* ``)``

      bestimmtes Integral

+     ``Int``

      Integral nur anzeigen

Ersetzungen
===========

+     ``eval(`` *expr* ``, {`` *a* ``=`` *A* ``,`` *b* ``=`` *B* ``,``
      ... ``,`` *z* ``=`` *Z* ``})``

      in *expr* werden *a*, *b*, ..., *z* durch  *A*, *B*, ..., *Z* ersetzt.

+     ``simplify(`` *epr* ``, {`` *a* ``=`` *A* ``,`` *b* ``=`` *B* ``,``
      ... ``,`` *z* ``=`` *Z* ``})``

      Vereinfachung unter den angegebenen Nebenbedingungen

+     ``collect(`` *p* ``,`` *x* ``)``

      fasst im Polynom *p* alle *x*-Potenzen zusammen (*p* muss
      expandiert sein) 

Ausdrücke vs Funktionen
=======================

+     ``(`` *a* ``,`` *b* ``,`` ... ``,`` *z* ``) ->`` *expr*

      Funktion der Variablen *a*, *b*, ..., *z*, deren Funktionsvorschrift
      durch *expr* gegeben ist 
 
+     ``unapply(`` *expr* ``,`` *a* ``,`` *b* ``,`` ... ``,`` *z* ``)``

      wandelt den Ausdruck *expr* in eine Funktion der Variablen *a*, *b*,
      ..., *z* um	

Funktionsgraphen
================

+     ``plot(`` *expr* ``,`` *x* ``=`` *a* ``..`` *b* ``)``

      zeigt den Graph des Ausdrucks *expr* für *x* von *a* bis *b*

+     ``plot(`` *f* ``,`` *a* ``..`` *b* ``)``

      zeigt den Graph der Funktion *f* über dem Intervall [*a*, *b*]

+     ``plot([`` *ex_1* ``,`` *ex_2* ``,`` ... ``,`` *ex_n* ``],`` *x*
      ``=`` *a* ``..`` *b* ``, color = [`` *farbe_1* ``,`` *farbe_2* 
      ``,`` ... ``,`` *farbe_n*	``])``

      zeigt die Graphen der Ausdrücke *ex_1*, *ex_2*, ..., *ex_n* für
      *x* von *a* bis *b* in einem Fenster, jeden in der angegebenen
      Farbe 

+     ``plot([`` *f_1* ``,`` *f_2* ``,`` ... ``,`` *f_n* ``],`` *a* ``..`` 
      *b* ``, color = [`` *farbe_1* ``,`` *farbe_2* ``,`` ... ``,`` 
      *farbe_n* ``])``

      dasselbe für Funktionen 

+     hinter dem Argumentbereich kann ein Wertebereich in der
      gleichen Form angegeben werden 

+     Die folgenden Optionen können nachgestellt werden
      
      +  ``axes = boxed``

         Koordinatenachsen; Alternativen sind ``normal``, ``framed``, ``none``

      +  ``discont = true``

	 Suche nach Sprungstellen einschalten

      +  ``thickness =`` *n*

	 Strichdicke, erlaubt sind *n* = 0,1,2,3

      +  ``numpoints =`` *n*

	 *n* Funktionsauswertungen verwenden

      +  ``scaling = constrained``

	 alle Achsen verwenden denselben Maßstab

..      siehe auch `ebene parametrische Plots`_ und `logplot` im
..      Abschnitt Datenimport_


Maple rechnet komplex
=====================

+     ``I``

      imaginäre Einheit

+     ``sqrt(`` *x* ``)``

      Quadratwurzel

+     ``Re(`` *z* ``), Im(`` *z* ``)``

      Real- und Imaginärteil

+     ``conjugate(`` *z* ``)``

      komplex Konjugierte 

+     ``abs(`` *z* ``)``

      Absolutbetrag

*     ``csgn``

      komplexe Vorzeichenfunktion

+     *befehl* ``assuming`` *property_1* ``,`` *property_2* ``,`` ... ``,``
      *property_n*

      *befehl* wird unter den zusätzlichen Annahmen *property_1*, ...,
      *property_n* ausgeführt

      wichtige Beispiele für properties:
      
      *		*x* ``> 2``

      *         *y* ``<=`` *x*

      *         *x* ``::real``

      *		*x* ``::positive``

      *		*n* ``::integer``

      *		*n* ``::odd``

      *		*n* ``::even``

+     ``evalc(`` *ausdruck* ``)``

      ausdruck wird unter der Annahme ausgewertet, dass alle
      auftretenden Variablen reell sind      

Lektion 3
*********

3D-Funktionsgraphen
===================

+     ``plot3d(`` *expr* ``,`` *x* ``=`` *a* ``..`` *b* ``,`` 
      *y* ``=`` *c* ``..`` *d* ``)``

      zeigt den Graph des Ausdrucks *expr* für *x* von *a* bis *b* und
      *y* von *c* bis *d*

+     ``plot3d(`` *f* ``,`` *a* ``..`` *b* ``,`` *c* ``..`` *d* ``)``

      zeigt den Graph der Funktion *f* über dem Rechteck [*a*,
      *b*]x[*c*, *d*]

+     Zusätzliche Optionen nur für 3D

      * ``view =`` *e* ``..`` *f*

	Wertebereich auf [*e*, *f*] einschränken

      * ``shading = zhue``

	höhenabhängige Farbwerte

      * ``style = patchcontour``

	Höhenlinien, Alternativen: ``patch``, ``patchnogrid``, ``wireframe``

      * ``transparency =`` *t*

	Transparenz festlegen, *t* liegt zwischen 0 und 1, dabei führt
	1 zu einem vollständig durchsichtigen Plot

      * ``orientation = [`` *phi* ``,`` *psi* ``]``

	Ort des Betrachters festlegen


Listen und Mengen
=================

+     ``[`` *a* ``,`` *b* ``,`` ... ``,`` *z* ``]``

      Liste

+     ``{`` *a* ``,`` *b* ``,`` ... ``,`` *z* ``}``

      Menge

+     *a* ``,`` *b* ``,`` ... ``,`` *z*

      Folge (Achtung: eine Folge wird nicht als Einzelobjekt
      verstanden) 

+     ``seq(`` *ausdr* ``,`` *j* ``=`` *a* ``..`` *b* ``)``

      Erzeugung einer Folge

+     ``nops(`` *liste* ``)``
   
      Anzahl der Elemente; statt *liste* ist auch eine Menge oder
      eine Folge zulässig

+     ``convert(`` *expr*, *type* ``)``

      Umwandlung des Ausdrucks *expr* in ein Objekt des Typs *type*.
      Wichtige Typen sind:

      * list

      Liste

      * set

      Menge

      * ``'+'``

      Summe

      siehe auch `Trigonometrische Funktionen`_

Schleifen
=========

+     ``for`` *l* ``in`` *list* ``do;`` *befehl_1* ``;``
      ... *befehl_n* ``; end do;``

      Schleife über alle Elemente der Liste *list*

+     ``for`` *i* ``from`` *a* ``to`` *b* ``do;`` 
      *befehl_1* ``;`` ... *befehl_n* ``; end do;``

      Schleife für *i* von *a* bis *b*, beide einschließlich 

Lektion 4
*********

automatisches Lösen von Gleichungen
===================================

+     ``solve(`` *Glg* ``,`` *x* ``)``

      löst Gleichung *Glg* nach der Variablen *x*

+     ``solve(`` *Gls* ``,`` *vars* ``)``

      löst Gleichungssystem *Gls* nach den Variablen
      *vars*, dabei sind *Gls* und *vars* Mengen

+     ``solve(`` ..., ``Explicit)``

      ``RootOf``-Notation wird nach Möglichkeit vermieden

+     ``is(`` *expr* ``)``

      stellt den Wahrheitsgehalt von *expr* fest

+     ``fsolve``

      wie ``solve``, aber numerisch;

      folgende Optionen
      
      *		``complex``

		suche auch nach komplexen Nullstellen

      *		*x* ``=`` *x_0*

		Startwert der Suche ist x_0

+     ``RootOf``

      Notation zur Darstellung von Lösungen

+     ``map(`` *f* ``,`` *liste* ``,`` *opt* ``)``

      auf alle Elemente von *liste* wird die Funktion *f* angewandt; 
      *opt* ist eine Folge von Optionen der Funktion *f*,
      die auch leer sein darf 

Pakete
======

+     ``with(`` *paket* ``)``

      lädt die Bibliothek *paket*
  
Graphen von Lösungsmengen
=========================

+     ``with(plots)``

      lädt das Paket mit speziellen Grafikfunktionen

+     ``implicitplot(`` *Glg* ``,`` *x* ``=`` *a* ``..`` *b* ``,``
      *y* ``=`` *c* ``..`` *d* ``)`` 

      zeichnet die Lösungsmenge der Gleichung *Glg* in den
      Variablen *x* und *y* im angegebenen Bereich; statt
      einer Gleichung ist auch eine Menge von Gleichungen
      zulässig; es dürfen Plotoptionen angeschlossen werden;
      ``implicitplot`` gehört zum Paket ``plots``

+     ``plot_real_curve(`` *p* ``,`` *x* ``,`` *y* ``)``

      zeichnet die Nullstellen des Polynoms *p* in den Variablen *x*
      und *y*; Plotoptionen sind zulässig; ``plot_real_curve`` gehört
      zum Paket ``algcurves``

Lösen von Polynomgleichungen
============================

+ ``@``

  Verknüpfungsoperator

Lösung transzendenter Gleichungen
===================================

+ ``solve(`` ..., ``allsolutions)``

  bei transzendenten Gleichungen alle Lösungen bestimmen 

+ ``about(`` *x* ``)``

  bestehende Annahmen über *x* anzeigen

+ ``fsolve(`` *Glg* ``,`` *x* ``=`` *a* ``..`` *b* ``)``

  Option von ``fsolve``, um den Suchbereich einzuschränken

+ ``series(`` *expr*, ``,`` *x* ``=`` *a* ``,`` *n* ``)``

  Reihenentwicklung des Ausdrucks *expr* im Punkt *a* nach der
  Variablen *x* zur Ordnung *n*.  Der Punkt darf *infinity* sein.

Lektion 05
**********

Träge Operatoren
================

+ ``Sum, Int, Diff``

  Varianten vom ``sum``, ``int``, ``diff``, bei denen Summe, Integral
  und Ableitung nur dargestellt, aber nicht ausgewertet werden

+ ``value``
  
  Befehl zur Auswertung der trägen Operatoren

+ ``'``

Zusammenfassen
===============

+ ``collect(`` *poly* ``,`` *var* ``)``

  *poly* ist ein expandiertes Polynom; die Terme gleicher Potenz in
  *var* werden zusammengefasst
 
+ ``collect(`` *poly* ``,`` *liste* ``)``

  dasselbe für Polynome in mehreren Veränderlichen; die zu
  berücksichtigenden Veränderlichen sind in *liste* aufgezählt und
  werden der Reihe nach abgearbeitet

Trigonometrische Funktionen
===========================

+ ``sin``, ``cos``, ``tan``, ``cot``, ``arcsin``, ``arccos``,
  ``arctan``

  Trigonometrische Funktionen

+ ``expand``

  Anwendung der Additionstheoreme aif trigonometrische Funktionen

+ ``combine``

  Umkehrung von ``expand``, wo sinnvoll

+ ``trigsubs``

  schlägt äquivalente trigonometrische Ausdrücke vor

+ ``convert(`` *ausdruck* ``, sincos)``

  Tangens und exp(*ix*) werden in Sinus- und Cosinusfunktionen
  umgewandelt

Potenzfunktionen
================

+ ``surd(`` *x* ``,`` *n* ``)``

  reelle *n*-te Wurzel aus reellem *x*

Integration
===========

+ ``piecewise``

  stückweise definierter Ausdruck

gesteuerte Integration
======================

+ ``Change(`` *Int* ``,`` *ersetzung* ``)``

  Integration durch Substitution, hierbei sind *ersetzung* die
  Substitution als Gleichung und *Int* ein unausgewertetes Integral;
  ``Change`` ist Bestandteil des Pakets ``IntegrationTools``

+ ``Parts(`` *Int* ``,`` *u* ``)``

  Partielle Integration, hierbei ist *Int* ein unausgewertetes
  Integral und *u* der Faktor, der abgeleitet wird; ``Parts`` ist
  Bestandteil des Pakets ``IntegrationTools``

zurück zum Inhaltsverzeichnis_

----------------------

© 2014 `Rüdiger Braun`_

zurück zur Homepage_ 

.. _Homepage: http://compana.ruediger-braun.net
.. _`Rüdiger Braun`: mailto:Ruediger.Braun@uni-duesseldorf.de
